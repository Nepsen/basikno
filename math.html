<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter Explorer</title>
    <!-- Inter font from Google Fonts for universal readability across various devices -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN for responsive and modern styling, providing utility classes for rapid development -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define your color palette using CSS variables for easy theme management and consistency */
        :root {
            /* Dark Mode Variables: Deep, vibrant colors for an immersive feel */
            --dark-space: #0f0a1c; /* Even deeper background, almost black with a purple tint */
            --deep-purple: #2c0b4f; /* Main container/card background, richer dark purple */
            --electric-blue: #0084ff; /* Slightly brighter electric blue for main accents */
            --cosmic-purple: #7a1ee6; /* Vivid purple for subtle accents and borders */
            --light-purple: #e9d3ff; /* Lighter purple, ideal for text on dark backgrounds to ensure readability */
            --accent-blue: #00b0ff; /* Another bright blue for strong emphasis and interactive elements */
            --text-dark-mode: var(--light-purple); /* Default text color in dark mode */
            --shadow-dark-mode-1: rgba(0, 0, 0, 0.6); /* Deeper primary shadow */
            --shadow-dark-2: rgba(74, 0, 114, 0.4); /* Secondary shadow with a purple tint */

            /* Light Mode Variables: Clean, softer colors for a brighter interface */
            --light-bg: #f0f2f5; /* Soft grey background for light mode */
            --light-text: #2c3e50; /* Darker text for better contrast on light backgrounds */
            --light-accent: #673ab7; /* Muted purple accent for light mode elements */
            --light-border: #d7ccc8; /* Light grey-purple for borders/separators in light mode */
            --light-card: #ffffff; /* Pure white for card backgrounds in light mode */
            --shadow-light-mode-1: rgba(0, 0, 0, 0.15); /* Primary shadow for light mode */
            --shadow-light-mode-2: rgba(94, 53, 177, 0.1); /* Secondary shadow with a subtle purple tint */
        }

        /* Base body styling: sets font, background, and default text color based on theme */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, var(--dark-space) 0%, #3a0e69 100%); /* Elegant gradient background */
            color: var(--text-dark-mode); /* Default to dark mode text color */
            transition: background 0.5s ease, color 0.3s ease; /* Smooth transition for theme changes */
            display: flex;
            flex-direction: column;
            align-items: center; /* Centers content horizontally */
            min-height: 100vh; /* Ensures body takes at least full viewport height */
            padding: 20px;
            box-sizing: border-box; /* Includes padding in element's total width and height */
            line-height: 1.7; /* Optimized line height for enhanced readability */
            font-size: 1.05rem; /* Slightly larger base font size for premium feel */
        }

        /* Light mode specific styles: overrides dark mode defaults when 'light-mode' class is applied */
        body.light-mode {
            background: linear-gradient(135deg, var(--light-bg) 0%, #ffffff 100%); /* Soft gradient for light mode */
            color: var(--light-text);
        }

        /* Container styling: central content area with rounded corners and shadow */
        .container {
            background-color: var(--deep-purple); /* Container background in dark mode */
            border-radius: 25px; /* Softer, more pronounced rounded corners */
            padding: 30px;
            box-shadow: 0 15px 40px var(--shadow-dark-mode-1), 0 5px 20px var(--shadow-dark-2); /* Multi-layered shadow for depth */
            width: 100%; /* Ensures responsiveness across screen sizes */
            max-width: 960px; /* Increased max-width for a more expansive feel */
            transition: background-color 0.4s ease, box-shadow 0.4s ease; /* Smooth transition for theme changes */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle light border for definition */
            backdrop-filter: blur(5px); /* Adds a subtle frosted glass effect */
            -webkit-backdrop-filter: blur(5px); /* Safari support */
        }

        /* Light mode container styles */
        body.light-mode .container {
            background-color: var(--light-card); /* Light mode container background */
            box-shadow: 0 15px 40px var(--shadow-light-mode-1), 0 5px 20px var(--shadow-light-mode-2); /* Light mode multi-layered shadow */
            border: 1px solid rgba(0, 0, 0, 0.05); /* Subtle dark border for light mode */
        }

        /* Top controls wrapper for theme toggle and Google Translate, aligned to the right */
        .top-controls-wrapper {
            display: flex;
            align-items: center;
            justify-content: flex-end; /* Aligns items to the right */
            width: 100%;
            max-width: 960px; /* Match container max-width */
            margin-bottom: 25px;
            padding: 0 15px; /* Adjusted padding */
            gap: 20px; /* Increased space between elements */
            flex-wrap: wrap; /* Allows items to wrap onto the next line on smaller screens */
        }
        
        .theme-switch-wrapper {
            display: flex;
            align-items: center;
            color: var(--text-dark-mode);
            font-size: 0.95rem; /* Slightly larger text for switch label */
            font-weight: 500;
        }

        /* Light mode theme switch wrapper text color */
        body.light-mode .theme-switch-wrapper {
            color: var(--light-text);
        }

        /* Hidden checkbox styling for the theme switch */
        .theme-switch {
            display: inline-block;
            height: 38px; /* Slightly larger switch */
            position: relative;
            width: 68px; /* Slightly wider switch */
        }

        .theme-switch input {
            display: none; /* Hides the actual checkbox input */
        }

        /* Slider track for the theme toggle */
        .slider {
            background-color: #888; /* Darker neutral background for the toggle track */
            bottom: 0;
            cursor: pointer;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            transition: .4s; /* Smooth transition for slider movement */
            border-radius: 38px; /* Makes the track rounded */
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3); /* Inner shadow for depth */
        }

        /* Slider handle for the theme toggle */
        .slider:before {
            background-color: #fff; /* White handle */
            bottom: 4px;
            content: ""; /* Required for :before pseudo-element */
            height: 30px; /* Larger handle */
            left: 4px;
            position: absolute;
            transition: .4s; /* Smooth transition for handle movement */
            width: 30px; /* Larger handle */
            border-radius: 50%; /* Makes the handle circular */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4); /* Handle shadow */
        }

        /* Styles when the theme switch is checked (activates light mode) */
        input:checked + .slider {
            background-color: var(--electric-blue); /* Blue track when checked */
            box-shadow: inset 0 2px 5px rgba(0, 132, 255, 0.5); /* Inner shadow for checked state */
        }

        input:checked + .slider:before {
            transform: translateX(30px); /* Moves the handle to the right when checked */
            box-shadow: 0 2px 8px var(--shadow-dark-2); /* Handle shadow for checked state */
        }

        /* Google Translate Widget Styling: overrides default Google styles for theme integration */
        #google_translate_element {
            margin-left: 15px; /* Increased margin */
        }
        #google_translate_element .goog-te-gadget {
            font-family: 'Inter', sans-serif !important; /* Forces Inter font */
            font-size: 0.9rem !important; /* Slightly larger font size */
            color: var(--text-dark-mode) !important; /* Inherits theme text color */
            background-color: transparent !important; /* Transparent background */
            border: 1px solid var(--cosmic-purple) !important; /* Border color for the widget */
            border-radius: 10px; /* More rounded corners */
            overflow: hidden; /* Ensures content stays within bounds */
            padding: 6px 10px; /* Increased padding */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); /* Subtle shadow */
        }
        /* Light mode specific styling for Google Translate widget */
        body.light-mode #google_translate_element .goog-te-gadget {
            color: var(--light-text) !important;
            border: 1px solid var(--light-accent) !important;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
        }
        /* Styling for the Google Translate dropdown combo box */
        #google_translate_element .goog-te-gadget .goog-te-combo {
            background-color: transparent !important;
            color: inherit !important;
            border: none !important;
            outline: none !important;
            appearance: none; /* Hide default dropdown arrow */
            -webkit-appearance: none;
            -moz-appearance: none;
            padding-right: 20px; /* Space for custom arrow if added */
        }
        /* Hides the Google Translate banner frame to prevent UI shifts */
        .goog-te-banner-frame.skiptranslate {
            display: none !important;
        }
        /* Resets body top margin affected by Google Translate overlay */
        body {
            top: 0 !important; 
        }

        /* Next Chapter Link Styling */
        #next-chapter-link {
            background: linear-gradient(90deg, var(--cosmic-purple) 0%, var(--electric-blue) 100%); /* Gradient button */
            color: white;
            padding: 10px 20px;
            border-radius: 10px; /* More rounded */
            text-decoration: none;
            font-weight: 700; /* Bolder text */
            transition: all 0.3s ease; /* Smooth transition for all properties */
            box-shadow: 0 5px 15px rgba(138, 43, 226, 0.4); /* Deeper shadow */
            display: none; /* Hidden by default, shown when chapter is complete */
            letter-spacing: 0.05em; /* Slight letter spacing for premium look */
            text-transform: uppercase; /* Uppercase text */
        }

        /* Light mode next chapter link styles */
        body.light-mode #next-chapter-link {
            background: linear-gradient(90deg, var(--light-accent) 0%, #6200EE 100%); /* Light mode gradient */
            box-shadow: 0 5px 15px rgba(94, 53, 177, 0.3);
        }

        /* Hover effect for next chapter link */
        #next-chapter-link:hover {
            transform: translateY(-3px) scale(1.02); /* More pronounced lift and slight scale */
            box-shadow: 0 8px 20px rgba(138, 43, 226, 0.6); /* Even deeper shadow on hover */
            background-position: right center; /* Animate gradient direction */
            background-size: 200% auto; /* For gradient animation */
        }

        /* YouTube Player and External Game Container Styling */
        #youtube-player {
            position: relative; /* Needed for positioning the overlay */
            width: 100%;
            aspect-ratio: 16 / 9; /* Maintains 16:9 aspect ratio for videos */
            border-radius: 20px; /* More rounded corners */
            overflow: hidden; /* Clips content outside the rounded corners */
            border: 3px solid var(--accent-blue); /* Thicker, more prominent border */
            box-shadow: 0 0 25px rgba(0, 176, 255, 0.8), 0 0 50px rgba(0, 176, 255, 0.4); /* Double glow effect */
            transition: all 0.4s ease; /* Smooth transition for player focus */
        }
        #youtube-player:focus-within, #external-game-iframe:focus-within {
            transform: scale(1.01); /* Slight zoom on focus */
            box-shadow: 0 0 30px rgba(0, 176, 255, 1), 0 0 60px rgba(0, 176, 255, 0.6); /* More intense glow on focus */
        }

        /* Overlay to disable interaction with YouTube player controls */
        #youtube-player-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0); /* Transparent, but captures clicks */
            z-index: 10; /* Above the iframe */
            display: none; /* Hidden by default */
            cursor: not-allowed; /* Indicate that it's not interactive */
        }
        #youtube-player-overlay.active-overlay {
            display: block; /* Show when questions are active */
        }

        #external-game-container {
            margin-top: 30px; /* More spacing */
            text-align: center;
            background-color: var(--deep-purple);
            padding: 30px; /* More padding */
            border-radius: 20px;
            box-shadow: 0 8px 25px var(--shadow-dark-mode-1); /* Deeper shadow */
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }
        /* Light mode external game container styles */
        body.light-mode #external-game-container {
            background-color: var(--light-card);
            box-shadow: 0 8px 25px var(--shadow-light-mode-1);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        /* Styling for the "Mark Game as Complete" button */
        #mark-game-complete-btn {
            background: linear-gradient(90deg, var(--accent-blue) 0%, #00d4ff 100%); /* Gradient button */
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.05rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 15px rgba(0, 176, 255, 0.5);
            margin-top: 25px; /* More spacing */
            font-weight: 600;
            letter-spacing: 0.04em;
        }
        /* Hover effect for the game complete button */
        #mark-game-complete-btn:hover {
            background-position: right center;
            background-size: 200% auto;
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(0, 176, 255, 0.7);
        }
        /* Disabled state for the game complete button */
        #mark-game-complete-btn:disabled {
            background: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Loading spinner animation */
        .loading-spinner {
            border: 5px solid rgba(255,255,255,0.2);
            border-top: 5px solid var(--electric-blue);
            border-radius: 50%;
            width: 50px; /* Larger spinner */
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 30px auto; /* More margin */
            display: none; /* Hidden by default */
            filter: drop-shadow(0 0 8px var(--electric-blue)); /* Glow effect */
        }

        /* Keyframe animation for the spinner */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Questions section styling: container for checkpoint challenges */
        .questions-section { 
            background-color: var(--deep-purple);
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
            width: 100%;
            box-shadow: 0 10px 30px var(--shadow-dark-mode-1);
            transition: background-color 0.4s ease, box-shadow 0.4s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }
        /* Light mode questions section styles */
        body.light-mode .questions-section {
            background-color: var(--light-card);
            box-shadow: 0 10px 30px var(--shadow-light-mode-1);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        /* Styles for the area containing multiple text questions */
        .text-questions-area {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Increased space between individual question items */
            margin-bottom: 30px; /* More spacing */
            padding: 20px;
            background-color: rgba(74, 0, 114, 0.3); /* Softer semi-transparent background */
            border-radius: 15px; /* More rounded */
            border: 1px solid var(--cosmic-purple); /* Defined border */
        }
        /* Light mode text questions area styles */
        body.light-mode .text-questions-area {
            background-color: var(--light-border);
            border: 1px solid var(--light-accent);
        }

        /* Styling for individual question items */
        .text-question-item {
            padding: 15px; /* More padding */
            background-color: rgba(74, 0, 114, 0.5); /* Slightly darker semi-transparent background */
            border-radius: 12px; /* More rounded */
            color: var(--text-dark-mode);
            transition: background-color 0.3s ease; /* Smooth transition for feedback */
            border: 1px solid rgba(255, 255, 255, 0.05); /* Very subtle internal border */
        }
        /* Light mode text question item styles */
        body.light-mode .text-question-item {
            background-color: var(--light-card);
            color: var(--light-text);
            border: 1px solid rgba(0, 0, 0, 0.03);
        }
        .text-question-item p {
            font-weight: 600;
            margin-bottom: 10px; /* More space */
            font-size: 1.05rem;
        }
        .text-question-options label {
            display: flex; /* Use flex for better alignment of radio and text */
            align-items: center;
            margin-bottom: 8px; /* More space between options */
            cursor: pointer;
            padding: 5px 0; /* Vertical padding for click area */
            transition: color 0.2s ease;
        }
        .text-question-options label:hover {
            color: var(--electric-blue); /* Highlight text on hover */
        }
        body.light-mode .text-question-options label:hover {
            color: var(--light-accent);
        }
        .text-question-options input[type="radio"] {
            margin-right: 12px; /* More space from radio button */
            accent-color: var(--accent-blue); /* Colors the radio button itself */
            transform: scale(1.2); /* Slightly larger radio buttons for easier tapping */
            transition: transform 0.2s ease;
        }
        .text-question-options input[type="radio"]:checked {
            transform: scale(1.3); /* Slightly larger when checked */
        }

        /* Styling for the "Submit Challenge" button */
        #submit-challenge-btn {
            background: linear-gradient(90deg, var(--electric-blue) 0%, #00C6FF 100%); /* Gradient button */
            color: white;
            padding: 15px 35px; /* Larger padding */
            border: none;
            border-radius: 12px; /* More rounded */
            font-size: 1.15rem; /* Larger font */
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 20px rgba(0, 123, 255, 0.4); /* Deeper shadow */
            margin-top: 25px; /* More space */
            font-weight: 700; /* Bolder text */
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        /* Hover effect for submit button */
        #submit-challenge-btn:hover {
            background-position: right center;
            background-size: 200% auto;
            transform: translateY(-4px) scale(1.03); /* More pronounced lift and scale */
            box-shadow: 0 12px 25px rgba(0, 123, 255, 0.6); /* Even deeper shadow on hover */
        }
        /* Disabled state for submit button */
        #submit-challenge-btn:disabled {
            background: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Modern Message Box Styles: used for custom alerts instead of browser's alert() */
        .message-box {
            position: fixed; /* Fixed position relative to the viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Darker overlay */
            display: flex; /* Centers content using flexbox */
            align-items: center;
            justify-content: center;
            z-index: 1000; /* Ensures it's on top of all other content */
            backdrop-filter: blur(8px); /* More pronounced blur effect */
            -webkit-backdrop-filter: blur(8px);
            opacity: 0; /* Start hidden for animation */
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .message-box.active {
            opacity: 1;
            visibility: visible;
        }

        /* Content area of the message box */
        .message-box-content {
            background-color: var(--deep-purple);
            color: var(--text-dark-mode);
            padding: 40px; /* More padding */
            border-radius: 20px; /* More rounded */
            box-shadow: 0 20px 50px var(--shadow-dark-mode-1), 0 5px 20px var(--shadow-dark-2); /* Deeper, multi-layered shadow */
            max-width: 450px; /* Slightly wider */
            text-align: center;
            transform: scale(0.8); /* Starts smaller for pop-in */
            animation: popIn 0.4s forwards cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Smoother pop-in animation */
            border: 1px solid rgba(255, 255, 255, 0.2); /* Defined border */
            opacity: 0; /* Start hidden for animation */
        }

        /* Light mode message box content styles */
        body.light-mode .message-box-content {
            background-color: var(--light-card);
            color: var(--light-text);
            box-shadow: 0 20px 50px var(--shadow-light-mode-1), 0 5px 20px var(--shadow-light-mode-2);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* Keyframe animation for the pop-in effect */
        @keyframes popIn {
            from { transform: scale(0.7); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .message-box-content p {
            margin-bottom: 25px; /* More space */
            font-size: 1.2rem; /* Larger font for message */
            font-weight: 500;
        }

        /* OK button inside the message box */
        .message-box-content button {
            background: linear-gradient(90deg, var(--accent-blue) 0%, #00e0ff 100%); /* Gradient button */
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.05rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 176, 255, 0.5);
            font-weight: 600;
            letter-spacing: 0.04em;
        }

        /* Hover effect for message box button */
        .message-box-content button:hover {
            background-position: right center;
            background-size: 200% auto;
            transform: translateY(-2px) scale(1.01);
            box-shadow: 0 8px 20px rgba(0, 176, 255, 0.7);
        }

        /* Styling for the "Get Hint" button */
        .hint-button {
            background: linear-gradient(90deg, #6c5ce7 0%, #a29bfe 100%); /* Purple-blue gradient */
            color: white;
            padding: 8px 16px; /* Slightly larger padding */
            border-radius: 8px; /* More rounded */
            font-size: 0.85rem; /* Slightly larger font */
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(108, 92, 231, 0.4);
            margin-top: 12px; /* More space from options */
            display: inline-block; 
            margin-right: 15px; /* More space between buttons */
            font-weight: 600;
            letter-spacing: 0.03em;
        }
        /* Hover effect for hint button */
        .hint-button:hover {
            background-position: right center;
            background-size: 200% auto;
            transform: translateY(-2px) scale(1.01);
            box-shadow: 0 5px 12px rgba(108, 92, 231, 0.6);
        }

        /* Styling for the hint display area */
        .hint-display {
            background-color: rgba(0, 176, 255, 0.15); /* Slightly more opaque background for hint */
            border-left: 5px solid var(--accent-blue); /* Thicker left border */
            padding: 12px; /* More padding */
            margin-top: 15px; /* More margin */
            border-radius: 8px; /* More rounded */
            color: var(--text-dark-mode); 
            font-size: 0.95rem; /* Slightly larger font */
            font-style: italic;
            display: none; /* Hidden by default, shown when hint is generated */
            line-height: 1.5;
            animation: fadeIn 0.5s ease-out; /* Fade in animation */
        }
        /* Light mode hint display styles */
        body.light-mode .hint-display {
            background-color: rgba(94, 53, 177, 0.1);
            border-left-color: var(--light-accent);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Styles for generated visual aids (images) */
        .question-visual-aid {
            max-width: 100%; 
            height: auto; 
            border-radius: 15px; 
            margin-top: 20px; 
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5); 
            border: 2px solid var(--cosmic-purple); 
            display: block; 
            margin-left: auto; 
            margin-right: auto; 
            transition: all 0.3s ease;
        }
        body.light-mode .question-visual-aid {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
            border: 2px solid var(--light-accent);
        }
        .question-visual-aid:hover {
            transform: scale(1.01);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.6);
        }

        /* Animations for Victory and Game Over */
        .victory-animation, .gameover-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            flex-direction: column;
            color: white;
            font-size: 3rem;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255,255,255,0.7);
        }

        .victory-animation.active, .gameover-animation.active {
            opacity: 1;
            visibility: visible;
        }

        .victory-animation span, .gameover-animation span {
            display: block;
            margin-top: 20px;
            font-size: 1.5rem;
            font-weight: 600;
        }

        /* Victory Specifics */
        .victory-animation {
            background: linear-gradient(135deg, #4CAF50 0%, #8BC34A 100%); /* Green gradient */
        }
        .victory-animation h2 {
            animation: bounceIn 1s ease-out forwards;
            color: white;
        }
        .victory-animation .checkmark {
            font-size: 5rem;
            animation: fadeInScale 1s ease-out forwards;
            animation-delay: 0.3s;
            display: block;
            margin-bottom: 20px;
        }

        /* Game Over Specifics */
        .gameover-animation {
            background: linear-gradient(135deg, #f44336 0%, #e91e63 100%); /* Red gradient */
        }
        .gameover-animation h2 {
            animation: shake 0.5s ease-in-out forwards;
            color: white;
        }
        .gameover-animation .crossmark {
            font-size: 5rem;
            animation: fadeInRotate 1s ease-out forwards;
            animation-delay: 0.3s;
            display: block;
            margin-bottom: 20px;
        }

        /* Keyframe animations for victory/gameover */
        @keyframes bounceIn {
            0% { transform: scale(0.1); opacity: 0; }
            60% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); }
        }

        @keyframes fadeInScale {
            0% { opacity: 0; transform: scale(0.5); }
            100% { opacity: 1; transform: scale(1); }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-10px); }
            40%, 80% { transform: translateX(10px); }
        }
        @keyframes fadeInRotate {
            0% { opacity: 0; transform: scale(0.5) rotate(-90deg); }
            100% { opacity: 1; transform: scale(1) rotate(0deg); }
        }
    </style>
</head>
<body>
    <div class="top-controls-wrapper">
        <a id="next-chapter-link" href="math1.html">Go to Next Chapter</a>
        <div class="theme-switch-wrapper">
            <label class="theme-switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
            <span class="ml-2">Dark/Light Mode</span>
        </div>
        <!-- Google Translate Element will be initialized here dynamically -->
        <div id="google_translate_element"></div>
    </div>

    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-6">Chapter Explorer</h1>
        <div id="youtube-player">
            <!-- YouTube Iframe will be injected here by the API -->
            <div id="youtube-player-overlay"></div> <!-- Overlay to block clicks -->
        </div>
        <div id="video-info" class="mt-4 text-center text-sm">
            <p><strong>Current Chapter:</strong> <span id="chapter-display"></span></p>
            <p><strong>Current Score:</strong> <span id="score-display">0</span></p>
            <p><strong>Level Progress:</strong> <span id="level-display">0</span></p>
            <p><strong>User ID:</strong> <span id="user-id-display">Loading...</span></p>
        </div>
        <div class="loading-spinner" id="loading-spinner"></div>

        <div id="questions-section" class="questions-section mt-6 hidden">
            <h2 class="text-2xl font-bold mb-4 text-center">Checkpoint Challenge</h2>
            
            <!-- Area where individual checkpoint questions will be dynamically loaded -->
            <div id="text-questions-area" class="text-questions-area"></div>

            <button id="submit-challenge-btn" disabled>Submit Challenge</button>
        </div>

        <!-- Final Game Challenge Section: displays an external game in an iframe -->
        <!-- This section is only shown if the user explicitly needs to play the game (e.g., didn't meet 80% score) -->
        <div id="external-game-container" class="hidden">
            <h2 class="text-2xl font-bold mb-4 text-center">Final Game Challenge!</h2>
            <p>Interact with the game below to complete this chapter.</p>
            <iframe id="external-game-iframe" frameborder="0" allowfullscreen></iframe>
            <button id="mark-game-complete-btn">Mark Game as Complete</button>
        </div>
    </div>

    <!-- Custom Message Box HTML: Replaces standard alert/confirm dialogs -->
    <div id="message-box" class="message-box">
        <div class="message-box-content">
            <p id="message-text"></p>
            <button id="message-ok-btn">OK</button>
        </div>
    </div>

    <!-- Victory Animation Overlay -->
    <div id="victory-animation" class="victory-animation">
        <div class="checkmark">✅</div>
        <h2>VICTORY!</h2>
        <span>Chapter Completed Successfully!</span>
    </div>

    <!-- Game Over Animation Overlay -->
    <div id="gameover-animation" class="gameover-animation">
        <div class="crossmark">❌</div>
        <h2>GAME OVER</h2>
        <span>Keep Trying!</span>
    </div>

    <script type="module">
        // --- API Keys & External Links Configuration ---
        // IMPORTANT: Replace 'YOUR_YOUTUBE_API_KEY_HERE' with your actual YouTube Data API Key.
        // Get one from Google Cloud Console (APIs & Services -> Credentials -> Create credentials -> API Key).
        // Using an array of API keys for fallback in case one fails or hits quota limits.
        const YOUTUBE_API_KEYS = [
            'AIzaSyBNGX-ctd1bHFfKR1chi_xx6it7gaTbZOM',
            'AIzaSyC93w_UsnvHB1cY-QJFOIpVUVef0Kr9thU',
            'AIzaSyAx9tVUn94XOf_z0P8SgK4ONGvtYTnG5CQ',
            'AIzaSyCOXQjAi6p4AxAsmwRfiuAGyksC-GW7h0Q',
            'AIzaSyCBpRZt8Ixw-9lOCvpPHRNS0z2IY942sZQ'
        ];
        // Index to keep track of the currently active YouTube API key being used.
        let currentYoutubeApiKeyIndex = 0; 
        
        // GEMINI_API_KEYS: An array of Gemini API keys for fallback.
        const GEMINI_API_KEYS = [
            'AIzaSyD3N22MpwPfObp7SmuCzdAsdXduij1CAbg',
            'AIzaSyBrLFORMIa1Q73eot8KveqhFgHqpglI6YA',
            'AIzaSyDSO9QllEwb6GFzxmqLSvMEsbemoCHmSkc',
            'AIzaSyDSxBCZWuN4EkiKOAwHUNNHhsGc3U6s_hM',
            'AIzaSyBikw4QJ_U2GGFeGHiC9kX3K_BR677z74s'
        ];
        // Index to keep track of the currently active Gemini API key being used.
        let currentGeminiApiKeyIndex = 0;

        const GEMINI_MODEL = "gemini-2.0-flash"; // Specify the Gemini text model to use.
        const IMAGEN_API_MODEL = "imagen-3.0-generate-002"; // Specify the Imagen model for image generation.


        // --- USER CONFIGURABLE: PRIMARY VIDEO LINK ---
        // If provided and valid, the app will attempt to load this video first.
        // If left empty or invalid, it will fall back to searching based on CHAPTER_NAME.
        // Example: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'
        const USER_PROVIDED_VIDEO_LINK = 'https://www.youtube.com/watch?v=8cR_1Qi-tP4&ab_channel=PreschoolPrepCompany'; 


        // URL for the next chapter page. Update this as your learning path progresses.
        const NEXT_CHAPTER_URL = 'math1.html'; 
        // Placeholder for an external interactive game. Replace with a live URL to your game.
        // Example: 'https://your-domain.com/your-game/index.html' or 'https://example.itch.io/your-game'
        const EXTERNAL_GAME_URL = 'https://placehold.co/600x400/000000/FFFFFF?text=YOUR_GAME_URL_HERE'; 

        // Default coordinates and language information. Used as a fallback if geo-location fails.
        const DEFAULT_COORDS = { latitude: 21.4225, longitude: 39.8262, city: 'Makkah', country: 'Saudi Arabia', countryCode: 'SA' };

        // Define the current chapter's name. This is crucial as a keyword for YouTube video searches.
        // It helps find relevant content even if video titles don't exactly match.
        const CHAPTER_NAME = 'Counting Numbers'; 

        // --- DOM Element References ---
        // Caching DOM elements improves performance by reducing repeated lookups.
        const body = document.body;
        const themeToggle = document.getElementById('theme-toggle');
        const nextChapterLink = document.getElementById('next-chapter-link');
        const youtubePlayerDiv = document.getElementById('youtube-player');
        const youtubePlayerOverlay = document.getElementById('youtube-player-overlay'); // New overlay element
        const loadingSpinner = document.getElementById('loading-spinner');
        const questionsSection = document.getElementById('questions-section'); 
        const chapterDisplay = document.getElementById('chapter-display');
        const scoreDisplay = document.getElementById('score-display');
        const levelDisplay = document.getElementById('level-display');
        const userIdDisplay = document.getElementById('user-id-display');
        const videoInfo = document.getElementById('video-info'); // Reference to video info section

        // Custom Message Box Elements for user feedback (replacing browser's alert/confirm)
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageOkBtn = document.getElementById('message-ok-btn');

        // Checkpoint Challenge related elements
        const textQuestionsArea = document.getElementById('text-questions-area');
        const submitChallengeBtn = document.getElementById('submit-challenge-btn'); 

        // External Game related elements
        const externalGameContainer = document.getElementById('external-game-container');
        const externalGameIframe = document.getElementById('external-game-iframe');
        const markGameCompleteBtn = document.getElementById('mark-game-complete-btn');

        // Animation overlays
        const victoryAnimation = document.getElementById('victory-animation');
        const gameoverAnimation = document.getElementById('gameover-animation');

        // --- Global State Variables ---
        // These variables hold the current state of the application.
        let player; // Holds the YouTube Player API instance
        let currentVideoId = ''; // Stores the ID of the currently playing YouTube video
        let currentVideoDuration = 0; // Stores the duration of the current video in seconds
        let currentVideoTitle = ''; // Stores the title of the current video
        let currentVideoDescription = ''; // Stores the description of the current video
        let checkpoints = []; // Array to store generated checkpoints and their associated questions
        let currentCheckpointIndex = -1; // Tracks the user's progress through checkpoints
        let lastPlayedTime = 0; // Stores the last known playback time of the video, for resuming
        let lastCheckpointTime = 0; // Stores the video time when the last checkpoint was triggered

        // Unique user ID, persisted in Local Storage to track individual progress
        let currentUserId = localStorage.getItem('chapter_app_userId') || crypto.randomUUID(); 
        // If it's a new user, save the generated ID to Local Storage
        if (!localStorage.getItem('chapter_app_userId')) {
            localStorage.setItem('chapter_app_userId', currentUserId);
        }
        // Display a shortened version of the user ID in the UI for clarity
        userIdDisplay.textContent = currentUserId.substring(0, 8) + '...'; 

        // Global State Variables for current chapter progress (for 80% rule)
        // Corrected to be properties of window to ensure global accessibility
        window.correctQuestionsInCurrentChapter = 0;
        window.totalQuestionsAttemptedInCurrentChapter = 0;
        // Flag to indicate if questions need to be regenerated (after a checkpoint failure)
        window.needsQuestionRegeneration = false; 

        const CHAPTER_PASS_SCORE_PERCENTAGE = 80; // Required percentage to pass a chapter without the game
        const CHECKPOINT_PASS_SCORE_PERCENTAGE = 80; // Required percentage to pass a single checkpoint


        // --- Game Data Management Functions (using Local Storage for persistence) ---

        /**
         * Loads user game data (score, level, and chapter-specific progress) from Local Storage.
         * Initializes UI displays based on loaded data. Handles cases where data might be missing or corrupted.
         */
        function loadGameData() {
            // Check if this specific chapter is already marked as completed for the current user.
            const isChapterCompleted = localStorage.getItem(`chapterCompleted_${CHAPTER_NAME}_${currentUserId}`);
            if (isChapterCompleted === 'true') {
                console.log(`Chapter "${CHAPTER_NAME}" is already completed! Auto-redirecting to the next chapter.`);
                const currentPath = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                window.location.href = currentPath + NEXT_CHAPTER_URL;
                return; // Exit function if chapter is already complete.
            }

            // Load and parse total score. Includes error handling for invalid JSON.
            const storedScores = localStorage.getItem('scoreofbasikno');
            let currentTotalScore = 0;
            if (storedScores) {
                try {
                    const parsedScores = JSON.parse(storedScores);
                    if (Array.isArray(parsedScores)) { // Ensure it's an array
                        currentTotalScore = parsedScores.reduce((sum, item) => sum + (item.score || 0), 0);
                    } else {
                        console.error("Stored score data is not an array, resetting.");
                        localStorage.setItem('scoreofbasikno', '[]'); // Reset if invalid format
                    }
                } catch (e) {
                    console.error("Error parsing score data from localStorage, resetting.", e);
                    localStorage.setItem('scoreofbasikno', '[]'); // Reset if JSON parsing fails
                }
            } else {
                localStorage.setItem('scoreofbasikno', '[]'); // Initialize as empty array if not present
            }
            scoreDisplay.textContent = currentTotalScore; // Update score display

            // Load and parse current level. Handles potential NaN values.
            let currentLevel = parseInt(localStorage.getItem('levelofbasikno')) || 0;
            if (isNaN(currentLevel)) { 
                currentLevel = 0; // Default to 0 if parsing results in NaN
                localStorage.setItem('levelofbasikno', '0'); // Store default back to local storage
            }
            levelDisplay.textContent = currentLevel; // Update level display

            // Load chapter-specific progress (current checkpoint, last played time, and question counts)
            const chapterProgressKey = `chapterProgress_${CHAPTER_NAME}_${currentUserId}`;
            const savedChapterProgress = JSON.parse(localStorage.getItem(chapterProgressKey)) || {};

            currentCheckpointIndex = savedChapterProgress.currentCheckpointIndex !== undefined ? savedChapterProgress.currentCheckpointIndex : -1;
            lastCheckpointTime = savedChapterProgress.lastCheckpointTime !== undefined ? savedChapterProgress.lastCheckpointTime : 0;
            window.correctQuestionsInCurrentChapter = savedChapterProgress.correctQuestions || 0;
            window.totalQuestionsAttemptedInCurrentChapter = savedChapterProgress.totalQuestions || 0;
            
            console.log('Game data loaded from Local Storage:', { 
                score: scoreDisplay.textContent, 
                level: levelDisplay.textContent, 
                savedChapterProgress, 
                correctQuestionsInCurrentChapter: window.correctQuestionsInCurrentChapter, 
                totalQuestionsAttemptedInCurrentChapter: window.totalQuestionsAttemptedInCurrentChapter 
            });
        }

        /**
         * Saves the current game progress (current checkpoint index and video playback time) to Local Storage.
         * This ensures progress is retained across sessions. Also saves chapter question counts.
         */
        function saveGameData() {
            const chapterProgressKey = `chapterProgress_${CHAPTER_NAME}_${currentUserId}`;
            const progressData = {
                currentCheckpointIndex: currentCheckpointIndex,
                lastCheckpointTime: lastCheckpointTime,
                correctQuestions: window.correctQuestionsInCurrentChapter,
                totalQuestions: window.totalQuestionsAttemptedInCurrentChapter
            };
            localStorage.setItem(chapterProgressKey, JSON.stringify(progressData)); // Stringify object for storage
            console.log('Game progress saved to Local Storage:', progressData);
        }

        /**
         * Updates the user's score in Local Storage and on the UI.
         * Scores are stored as an array of objects, allowing for detailed history if needed.
         * @param {number} pointsToAdd The number of points to add for this specific event.
         * @param {string} type The type of score event (e.g., 'question', 'checkpoint_bonus', 'game', 'chapter_completion').
         */
        function updateScore(pointsToAdd, type = 'question') {
            let scoresArray = [];
            const storedScores = localStorage.getItem('scoreofbasikno');
            if (storedScores) {
                try {
                    scoresArray = JSON.parse(storedScores);
                    if (!Array.isArray(scoresArray)) scoresArray = []; // Ensure it's an array
                } catch (e) {
                    console.error("Error parsing score data from localStorage for update, starting fresh.", e);
                    scoresArray = [];
                }
            }
            
            // Add a new score entry, including the chapter name (subject), score, type, and date.
            scoresArray.push({
                subject: CHAPTER_NAME, // 'subject' key aligns with potential external score tracking
                score: pointsToAdd,
                type: type, 
                date: new Date().toISOString() // ISO string for consistent date format
            });

            localStorage.setItem('scoreofbasikno', JSON.stringify(scoresArray)); // Save updated array

            // Recalculate total score from the array for accurate display
            const totalScore = scoresArray.reduce((sum, item) => sum + (item.score || 0), 0);
            scoreDisplay.textContent = totalScore; // Update UI
            console.log('Score updated:', totalScore);
        }

        /**
         * Updates the user's level in Local Storage and on the UI.
         * @param {number} levelsToAdd The number of levels to add.
         */
        function updateLevel(levelsToAdd) {
            let currentLevel = parseInt(localStorage.getItem('levelofbasikno')) || 0;
            currentLevel += levelsToAdd;
            localStorage.setItem('levelofbasikno', currentLevel.toString()); // Store as string
            levelDisplay.textContent = currentLevel; // Update UI
            console.log('Level upgraded to:', currentLevel); // Log to confirm level update
        }

        /**
         * Calculates the percentage of correct answers for the current chapter.
         * @returns {number} The percentage (0-100).
         */
        function getChapterCompletionPercentage() {
            if (window.totalQuestionsAttemptedInCurrentChapter === 0) return 0;
            return (window.correctQuestionsInCurrentChapter / window.totalQuestionsAttemptedInCurrentChapter) * 100;
        }

        /**
         * Marks the current chapter as complete, awards final points, updates level, and redirects to the next chapter.
         * This function is now only called when the chapter is truly completed (80%+ overall score).
         */
        function markChapterComplete() {
            // Check if the chapter was already marked complete to prevent duplicate actions
            const isChapterCompleted = localStorage.getItem(`chapterCompleted_${CHAPTER_NAME}_${currentUserId}`);
            if (isChapterCompleted === 'true') {
                console.log(`Chapter "${CHAPTER_NAME}" is already completed! Auto-redirecting to the next chapter.`);
                const currentPath = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                window.location.href = currentPath + NEXT_CHAPTER_URL;
                return; // Exit function if chapter is already complete.
            }

            updateScore(50, 'chapter_completion'); // Award bonus points for chapter completion
            updateLevel(1); // Increment user level

            // Mark the current chapter as completed in Local Storage for the current user.
            localStorage.setItem(`chapterCompleted_${CHAPTER_NAME}_${currentUserId}`, 'true');

            // Hide all main content sections before showing victory animation to prevent overlap
            youtubePlayerDiv.classList.add('hidden');
            videoInfo.classList.add('hidden');
            questionsSection.classList.add('hidden');
            externalGameContainer.classList.add('hidden');
            loadingSpinner.style.display = 'none';

            // Show victory animation, and then redirect upon its completion
            showVictoryAnimation('Chapter Completed Successfully!', () => {
                console.log('Redirecting to next chapter as chapter is fully completed with A+...');
                const currentPath = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                window.location.href = currentPath + NEXT_CHAPTER_URL;
            });
        }


        // --- Google Translate Initialization ---
        // This function is globally exposed as per Google Translate API requirements.
        window.googleTranslateElementInit = function() {
            new google.translate.TranslateElement({
                pageLanguage: 'en', // Defines the original language of your page content
                includedLanguages: 'en,ar,bn,es,fr,de,zh-CN', // List of languages offered to the user
                layout: google.translate.TranslateElement.InlineLayout.SIMPLE, // Simple dropdown layout
                autoDisplay: false // Prevents automatic display of the widget
            }, 'google_translate_element'); // ID of the DOM element to render the widget into
        };
        // Dynamically load the Google Translate script to prevent blocking HTML parsing.
        const translateScript = document.createElement('script');
        translateScript.type = 'text/javascript';
        translateScript.src = '//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit';
        document.head.appendChild(translateScript);

        // --- Utility Helper Functions ---

        /**
         * Displays a custom message box to the user with a given message.
         * This replaces standard browser alert() for better UI control and theming.
         * @param {string} message The text message to display inside the box.
         */
        function showMessageBox(message) {
            messageText.textContent = message;
            messageBox.classList.add('active'); // Add active class to show with animation
        }

        /**
         * Hides the custom message box.
         */
        function hideMessageBox() {
            messageBox.classList.remove('active'); // Remove active class to hide with animation
        }

        /**
         * Shows a victory animation overlay.
         * @param {string} message The message to display.
         * @param {function} [callback] An optional callback function to run after animation.
         */
        function showVictoryAnimation(message, callback = () => {}) {
            victoryAnimation.querySelector('span').textContent = message;
            victoryAnimation.classList.add('active');
            setTimeout(() => {
                victoryAnimation.classList.remove('active');
                callback(); // Execute callback after animation fades
            }, 3000); // Display for 3 seconds
        }

        /**
         * Shows a game over animation overlay.
         * @param {string} message The message to display.
         * @param {function} [callback] An optional callback function to run after animation.
         */
        function showGameOverAnimation(message, callback = () => {}) {
            gameoverAnimation.querySelector('span').textContent = message;
            gameoverAnimation.classList.add('active');
            setTimeout(() => {
                gameoverAnimation.classList.remove('active');
                callback(); // Execute callback after animation fades
            }, 3000); // Display for 3 seconds
        }


        /**
         * Extracts YouTube video ID from a given URL.
         * Supports various YouTube URL formats.
         * @param {string} url The full YouTube video URL.
         * @returns {string|null} The video ID or null if not found.
         */
        function getYouTubeVideoId(url) {
            const regex = /(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=|embed\/|v\/|)([\w-]{11})(?:\S+)?/;
            const match = url.match(regex);
            return match ? match[1] : null;
        }

        /**
         * Converts a two-letter country code into a common language code.
         * This is a simplified mapping for determining the preferred video language.
         * @param {string} countryCode Two-letter ISO country code (e.g., 'BD' for Bangladesh, 'US' for USA).
         * @returns {string} Corresponding two-letter language code (e.g., 'bn' for Bengali, 'en' for English).
         */
        function getLanguageFromCountry(countryCode) {
            switch (countryCode) {
                case 'BD': return 'bn'; // Bangladesh -> Bengali
                case 'SA': return 'ar'; // Saudi Arabia -> Arabic
                case 'US': case 'GB': case 'CA': case 'AU': return 'en'; // English speaking countries
                default: return 'en'; // Default to English if no specific mapping is found
            }
        }

        /**
         * Dynamically loads the YouTube Iframe API script.
         * This script is essential for embedding and programmatically controlling YouTube videos.
         */
        function loadYoutubeIframeAPI() {
            const tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            const firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        }

        // Promise to ensure YouTube Iframe API is ready before proceeding
        let youtubeApiReadyPromiseResolve;
        const youtubeApiReadyPromise = new Promise(resolve => {
            youtubeApiReadyPromiseResolve = resolve;
        });

        /**
         * Callback function automatically called by the YouTube Iframe API when it's fully loaded.
         * This now resolves the promise, allowing the rest of the initialization to proceed.
         */
        window.onYouTubeIframeAPIReady = function() {
            console.log("YouTube Iframe API is ready!");
            youtubeApiReadyPromiseResolve();
        };

        /**
         * Creates or updates the YouTube player with a specified video ID.
         * If a player already exists, it loads the new video; otherwise, it creates a new player instance.
         * @param {string} videoId The YouTube video ID to load and play.
         */
        function createYoutubePlayer(videoId) {
            // Defensive check: ensure YT and YT.Player are defined before attempting to create/load.
            if (typeof YT !== 'undefined' && typeof YT.Player === 'function') {
                if (player) {
                    // If a player already exists, simply load the new video by ID.
                    player.loadVideoById(videoId);
                } else {
                    // If no player exists, create a new one, embedding it into the 'youtube-player' div.
                    player = new YT.Player('youtube-player', {
                        videoId: videoId,
                        playerVars: {
                            'autoplay': 1, // Automatically starts playing the video when loaded
                            'controls': 1, // Displays player controls (play/pause, volume, etc.)
                            'rel': 0, // Prevents showing related videos at the end
                            'modestbranding': 1 // Uses a minimalist YouTube logo
                        },
                        events: {
                            'onReady': onPlayerReady, // Callback when the player finishes loading
                            'onStateChange': onPlayerStateChange // Callback for changes in playback state
                        }
                    });
                }
                currentVideoId = videoId; // Update global state with the new video ID
            } else {
                console.error("YT.Player is not defined. YouTube Iframe API might not be loaded yet or failed.");
                showMessageBox("Error: YouTube player failed to load. Please refresh the page.");
            }
        }

        /**
         * Callback function executed when the YouTube player is ready to begin playing.
         * Sets initial video state, handles resuming from saved progress, and starts monitoring.
         * @param {Object} event The event object provided by the YouTube API.
         */
        function onPlayerReady(event) {
            console.log('YouTube player ready!');
            currentVideoDuration = player.getDuration(); // Get total video duration
            console.log('Video duration:', currentVideoDuration, 'seconds');
            
            // Resume video from the last checkpoint if available, otherwise start from the beginning.
            if (lastCheckpointTime > 0) {
                lastPlayedTime = lastCheckpointTime;
                player.seekTo(lastPlayedTime, true); // Seek to the specific time
                showMessageBox(`Resuming chapter "${CHAPTER_NAME}" from ${formatTime(lastPlayedTime)}.`);
            } else {
                showMessageBox(`Starting chapter "${CHAPTER_NAME}". Enjoy!`);
            }
            loadingSpinner.style.display = 'none'; // Hide the loading indicator
            player.playVideo(); // Start video playback

            // Set up a continuous interval to check video progress for checkpoint triggers.
            setInterval(monitorVideoTime, 1000); // Check every second
        }

        /**
         * Callback function executed when the YouTube player's state changes (e.g., playing, paused, ended).
         * Manages UI visibility and video behavior based on playback state.
         * @param {Object} event The event object from the YouTube API.
         */
        function onPlayerStateChange(event) {
            // YT.PlayerState.ENDED (0): Video has finished playing.
            // YT.PlayerState.PLAYING (1): Video is currently playing.
            // YT.PlayerState.PAUSED (2): Video is paused.

            if (event.data === YT.PlayerState.ENDED) {
                console.log('Video ended.');
                const chapterPercentage = getChapterCompletionPercentage();

                // If video ended and user has achieved 80%+ overall score (A+)
                if (chapterPercentage >= CHAPTER_PASS_SCORE_PERCENTAGE) {
                    markChapterComplete(); // Chapter ends, with victory animation and next chapter redirect
                } else {
                    // If video ended and user has NOT achieved 80%+ overall score
                    showGameOverAnimation(`The video ended. Overall progress: ${chapterPercentage.toFixed(0)}%. Try again!`, () => {
                        // Clear chapter progress from local storage for a fresh start of the chapter
                        localStorage.removeItem(`chapterProgress_${CHAPTER_NAME}_${currentUserId}`);
                        // Perform a full page reload to reset all states for the chapter
                        window.location.reload(); 
                    });
                }
            } else if (event.data === YT.PlayerState.PLAYING) {
                // When video is playing, ensure question and game sections are hidden.
                questionsSection.classList.add('hidden');
                questionsSection.classList.remove('is-active'); // Removes an active state class
                externalGameContainer.classList.add('hidden'); // Hide the final game challenge
                youtubePlayerDiv.classList.remove('hidden'); // Ensure video player is visible
                videoInfo.classList.remove('hidden'); // Ensure video info is visible
                youtubePlayerOverlay.classList.remove('active-overlay'); // Enable player controls
                if (player) player.setPlaybackRate(1); // Ensures normal playback speed
            }
        }

        /**
         * Periodically monitors the video's current playback time to trigger checkpoints.
         * Pauses the video and displays questions when a checkpoint timestamp is reached.
         */
        function monitorVideoTime() {
            // Only proceed if player is ready, there are checkpoints, and questions are not currently active.
            if (!player || typeof player.getCurrentTime !== 'function' || checkpoints.length === 0 || questionsSection.classList.contains('is-active')) {
                return;
            }

            const currentTime = player.getCurrentTime();
            lastPlayedTime = currentTime;

            let shouldTriggerCheckpoint = false;
            let targetCheckpoint = null;

            // Scenario 1: Advancing to a new, unpassed checkpoint
            // Find the *first* checkpoint that is ahead of the current progress
            for (let i = currentCheckpointIndex + 1; i < checkpoints.length; i++) {
                if (currentTime >= checkpoints[i].timestamp) {
                    shouldTriggerCheckpoint = true;
                    targetCheckpoint = checkpoints[i];
                    currentCheckpointIndex = i; // Update index immediately to the newly triggered checkpoint
                    break;
                }
            }

            // Scenario 2: Re-triggering the *current* checkpoint after a failure and video rewind
            // This happens if the questions were hidden (due to failure) AND
            // the video time has now reached the current checkpoint's original timestamp.
            // Use a small buffer to ensure the trigger happens reliably right at the timestamp.
            if (!shouldTriggerCheckpoint && currentCheckpointIndex !== -1 && window.needsQuestionRegeneration) {
                const currentCpTimestamp = checkpoints[currentCheckpointIndex].timestamp;
                // Check if current time is within a small window around the checkpoint timestamp
                if (currentTime >= currentCpTimestamp - 0.5 && currentTime < currentCpTimestamp + 5) { 
                    shouldTriggerCheckpoint = true;
                    targetCheckpoint = checkpoints[currentCheckpointIndex];
                    // currentCheckpointIndex is already correctly set from the failure path, no need to update here
                }
            }

            if (shouldTriggerCheckpoint) {
                lastCheckpointTime = targetCheckpoint.timestamp; // Store this for potential future rewinds

                player.pauseVideo();
                player.setVolume(0);
                youtubePlayerOverlay.classList.add('active-overlay'); // Disable player controls

                youtubePlayerDiv.classList.add('hidden');
                videoInfo.classList.add('hidden');
                questionsSection.classList.remove('hidden'); // Show questions section
                questionsSection.classList.add('is-active'); // Mark as active

                if (window.needsQuestionRegeneration) {
                    // This is a re-attempt, regenerate new questions for the current checkpoint
                    window.needsQuestionRegeneration = false; // Reset the flag
                    showMessageBox(`Review complete! Generating new questions for this checkpoint...`);
                    // Ensure regenerating questions for the correct (current) checkpoint
                    regenerateCheckpointQuestions().then(() => {
                        displayTextQuestions(checkpoints[currentCheckpointIndex].text_questions);
                        hideMessageBox(); // Hide message box after new questions are displayed
                    }).catch(error => {
                        console.error("Error regenerating questions on reattempt:", error);
                        showMessageBox("Failed to load new questions. Please try again.");
                        loadingSpinner.style.display = 'none'; // Ensure spinner is hidden
                    });
                } else {
                    // This is the first time reaching this checkpoint
                    showMessageBox(`Checkpoint reached at ${formatTime(lastCheckpointTime)}! Answer all questions to continue.`);
                    displayTextQuestions(targetCheckpoint.text_questions);
                }
                saveGameData(); // Save game data (including updated currentCheckpointIndex)
            }
        }

        /**
         * Calculates a numerical relevance score for a video based on how well its title and description
         * match keywords from the current chapter name.
         * @param {string} videoTitle The title of the YouTube video.
         * @param {string} videoDescription The description of the YouTube video.
         * @param {string} chapterName The name/keyword of the current chapter.
         * @returns {number} A relevance score (higher means more relevant).
         */
        function calculateRelevance(videoTitle, videoDescription, chapterName) {
            // Split chapter name into significant keywords, filtering out common short words.
            const chapterKeywords = chapterName.toLowerCase().split(/\s+/)
                                        .filter(word => word.length > 2 && !['and', 'for', 'the', 'a', 'an', 'of', 'in', 'to', 'with', 'is', 'are', 'you', 'your'].includes(word));
            let score = 0;
            // Combine title and description into a single string for keyword searching.
            const combinedText = (videoTitle + ' ' + videoDescription).toLowerCase();

            // Award points for each keyword found in the video's combined text.
            chapterKeywords.forEach(keyword => {
                if (combinedText.includes(keyword)) {
                    score += 2; // Each match adds to relevance.
                }
            });

            // Provide a significant bonus for an exact match of the chapter name in the video title.
            if (videoTitle.toLowerCase().includes(chapterName.toLowerCase())) {
                score += 5;
            }

            return score;
        }

        /**
         * Fetches YouTube video details (snippet, contentDetails) for a given video ID.
         * It iterates through the available API keys until a successful response is received.
         * @param {string} videoId The YouTube video ID.
         * @returns {Promise<Object|null>} A promise resolving to a video details object or null if not found/error.
         */
        async function fetchVideoDetailsById(videoId) {
            if (!videoId) return null;
            let attempts = 0;
            while (attempts < YOUTUBE_API_KEYS.length) {
                const apiKey = YOUTUBE_API_KEYS[currentYoutubeApiKeyIndex % YOUTUBE_API_KEYS.length]; // Cycle through keys
                const videoDetailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&id=${videoId}&key=${apiKey}`;
                
                try {
                    console.log(`Attempting to fetch video details for ID: ${videoId} with YouTube key index: ${currentYoutubeApiKeyIndex % YOUTUBE_API_KEYS.length}`);
                    const response = await fetch(videoDetailsUrl);
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.items && data.items.length > 0) {
                            const videoDetails = data.items[0];
                            const durationSeconds = parseYouTubeDuration(videoDetails.contentDetails.duration);
                            currentYoutubeApiKeyIndex = 0; // Reset index on success to prioritize this key next time
                            return {
                                id: videoId,
                                snippet: videoDetails.snippet,
                                durationSeconds: durationSeconds,
                                relevanceScore: calculateRelevance(videoDetails.snippet.title, videoDetails.snippet.description, CHAPTER_NAME)
                            };
                        } else {
                             // If response is OK but no items, it means video not found or unavailable
                            console.warn(`Video ID ${videoId} not found or unavailable with YouTube key ${apiKey}.`);
                        }
                    } else if (response.status === 403 || response.status === 400) {
                        // 403 Forbidden or 400 Bad Request often means API key issue (invalid, quota exceeded, etc.)
                        console.warn(`YouTube API key "${apiKey}" failed with status ${response.status} for video details. Trying next key...`);
                    } else {
                        // Other HTTP errors (e.g., 500, 503)
                        console.error(`Error fetching details for video ID ${videoId} with YouTube key ${apiKey}: Status ${response.status} - ${response.statusText}`);
                    }
                } catch (error) {
                    // Network errors (e.g., no internet, DNS issues)
                    console.error(`Network error fetching details for video ID ${videoId} with YouTube key ${apiKey}:`, error);
                }
                
                currentYoutubeApiKeyIndex++; // Move to the next key for the next attempt
                attempts++;
            }
            console.error("All YouTube API keys failed to fetch video details.");
            return null; // All keys exhausted
        }

        /**
         * Fetches YouTube videos with details including duration and relevance score.
         * It iterates through the available API keys until a successful response is received.
         * @param {string} query The search query string for YouTube.
         * @param {number} maxResults The maximum number of search results to request from the API.
         * @returns {Promise<Array<Object>>} A promise resolving to an array of video objects,
         * each containing id, snippet, durationSeconds, and relevanceScore.
         */
        async function fetchVideosWithDetails(query, maxResults) {
            let videosWithCalculatedDetails = [];
            let attempts = 0;
            while (attempts < YOUTUBE_API_KEYS.length) {
                const apiKey = YOUTUBE_API_KEYS[currentYoutubeApiKeyIndex % YOUTUBE_API_KEYS.length]; // Cycle through keys
                const youtubeApiUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&order=viewCount&maxResults=${maxResults}&key=${apiKey}`;

                try {
                    const response = await fetch(youtubeApiUrl);
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.items && data.items.length > 0) {
                            for (const item of data.items.filter(i => i.id.kind === 'youtube#video')) {
                                // Use the *same* successful key for fetching individual video details
                                const videoDetailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&id=${item.id.videoId}&key=${apiKey}`; 
                                const detailsResponse = await fetch(videoDetailsUrl);
                                const detailsData = await detailsResponse.json();

                                if (detailsData.items && detailsData.items.length > 0) {
                                    const videoDetails = detailsData.items[0];
                                    const durationSeconds = parseYouTubeDuration(videoDetails.contentDetails.duration);
                                    const relevanceScore = calculateRelevance(videoDetails.snippet.title, videoDetails.snippet.description, CHAPTER_NAME);
                                    videosWithCalculatedDetails.push({
                                        id: item.id.videoId,
                                        snippet: videoDetails.snippet,
                                        durationSeconds: durationSeconds,
                                        relevanceScore: relevanceScore
                                    });
                                }
                            }
                            currentYoutubeApiKeyIndex = 0; // Reset index on success
                            return videosWithCalculatedDetails; // Return immediately on successful search and detail fetch
                        } else {
                            // If search response is OK but no items, it means no videos found for the query
                            console.warn(`No videos found for query "${query}" with YouTube key ${apiKey}.`);
                        }
                    } else if (response.status === 403 || response.status === 400) {
                        console.warn(`YouTube API key "${apiKey}" failed with status ${response.status} for search. Trying next key...`);
                    } else {
                        console.error(`Error fetching search results with YouTube key ${apiKey}: Status ${response.status} - ${response.statusText}`);
                    }
                } catch (error) {
                    console.error(`Network error fetching search results with YouTube key ${apiKey}:`, error);
                }
                
                currentYoutubeApiKeyIndex++; // Move to the next key for the next attempt
                attempts++;
            }
            console.error("All YouTube API keys failed to fetch search results.");
            return []; // Return empty array if all keys exhausted
        }


        /**
         * Searches for a relevant YouTube video based on the chapter name and user's language.
         * This function implements a robust, multi-phase search strategy, progressively
         * relaxing criteria (animated, non-animated, language, duration) until a suitable video is found.
         * It prioritizes relevance and longer duration.
         * @param {string} chapterName The keyword representing the chapter content.
         * @param {string} userLanguage The two-letter language code (e.g., 'bn', 'en').
         */
        async function searchYouTubeVideo(chapterName, userLanguage) {
            loadingSpinner.style.display = 'block'; // Show loading spinner
            chapterDisplay.textContent = `Searching for: ${chapterName}...`; // Update UI message

            let bestVideo = null;
            // Define minimum duration thresholds in seconds
            const minDuration30Min = 30 * 60; 
            const minDuration15Min = 15 * 60; 
            const minDuration5Min = 5 * 60;   

            // Define a sequence of search attempts, ordered by preference (most specific to most general)
            const searchAttempts = [
                // Phase 1: Prioritize 30+ minute videos
                // Attempt 1.1: Animated, User Language, 30+ min
                { querySuffix: `animated tutorial ${userLanguage}`, targetMinDuration: minDuration30Min, maxResults: 25, message: `Searching for animated, 30+ min videos in ${userLanguage}...` },
                // Attempt 1.2: Non-animated, User Language, 30+ min
                { querySuffix: `tutorial ${userLanguage}`, targetMinDuration: minDuration30Min, maxResults: 25, message: `No animated 30+ min video. Searching for non-animated, 30+ min videos in ${userLanguage}...` },
                // Attempt 1.3: Animated, English Fallback, 30+ min
                { querySuffix: `animated tutorial English`, targetMinDuration: minDuration30Min, maxResults: 25, message: `No 30+ min video in ${userLanguage}. Searching for animated, 30+ min videos in English...` },
                // Attempt 1.4: Non-animated, English Fallback, 30+ min
                { querySuffix: `tutorial English`, targetMinDuration: minDuration30Min, maxResults: 25, message: `No animated 30+ min video in English. Searching for non-animated, 30+ min videos in English...` },

                // Phase 2: If no 30+ min video found, target 15+ minute videos
                // Attempt 2.1: Animated, User Language, 15+ min
                { querySuffix: `animated tutorial ${userLanguage}`, targetMinDuration: minDuration15Min, maxResults: 25, message: `No very long video. Searching for animated, 15+ min videos in ${userLanguage}...` },
                // Attempt 2.2: Non-animated, User Language, 15+ min
                { querySuffix: `tutorial ${userLanguage}`, targetMinDuration: minDuration15Min, maxResults: 25, message: `No animated 15+ min video. Searching for non-animated, 15+ min videos in ${userLanguage}...` },
                // Attempt 2.3: Animated, English Fallback, 15+ min
                { querySuffix: `animated tutorial English`, targetMinDuration: minDuration15Min, maxResults: 25, message: `No 15+ min video in ${userLanguage}. Searching for animated, 15+ min videos in English...` },
                // Attempt 2.4: Non-animated, English Fallback, 15+ min
                { querySuffix: `tutorial English`, targetMinDuration: minDuration15Min, maxResults: 25, message: `No animated 15+ min video in English. Searching for non-animated, 15+ min videos in English...` },

                // Phase 3: Last Resort - Target 5+ minute videos, broader search
                // Attempt 3.1: Any type, User Language, 5+ min
                { querySuffix: `tutorial ${userLanguage}`, targetMinDuration: minDuration5Min, maxResults: 50, message: `Could not find specific video. Searching for any popular 5+ min tutorial on "${chapterName}" in ${userLanguage}...` },
                // Attempt 3.2: Any type, English Fallback, 5+ min
                { querySuffix: `tutorial English`, targetMinDuration: minDuration5Min, maxResults: 50, message: `Final attempt: Broad search for "${chapterName}" (any relevant 5+ min video)...` }
            ];

            // Iterate through each predefined search attempt until a suitable video is found.
            for (const attempt of searchAttempts) {
                showMessageBox(attempt.message); // Update user on current search strategy
                // Combine the base chapter name with the attempt's specific query suffix.
                // The `trim()` ensures no extra spaces if `querySuffix` is empty.
                const fullQuery = `${chapterName} ${attempt.querySuffix}`.trim(); 
                // Fetch videos with details. `videoDuration` API parameter is explicitly omitted here
                // as we fetch all results and filter by `targetMinDuration` locally for more control.
                let videos = await fetchVideosWithDetails(fullQuery, attempt.maxResults);

                // Filter the fetched videos based on the current attempt's minimum duration requirement.
                videos = videos.filter(v => v.durationSeconds >= attempt.targetMinDuration);

                // Sort the filtered videos:
                // 1. By relevance score (descending: most relevant first).
                // 2. Then by duration (descending: longest duration first, among equally relevant videos).
                videos.sort((a, b) => {
                    if (b.relevanceScore !== a.relevanceScore) {
                        return b.relevanceScore - a.relevanceScore; 
                    }
                    return b.durationSeconds - a.durationSeconds; 
                });

                // If any videos remain after filtering and sorting, select the best one and stop searching.
                if (videos.length > 0) {
                    bestVideo = videos[0];
                    console.log(`Found best video for attempt "${attempt.message}":`, bestVideo);
                    break; // Exit the loop as a suitable video has been found.
                }
            }
            
            // After all attempts, if a best video was found, initialize the player and checkpoints.
            if (bestVideo && bestVideo.id) {
                createYoutubePlayer(bestVideo.id); // Initialize YouTube player with the found video
                currentVideoDuration = bestVideo.durationSeconds; // Store video duration
                currentVideoTitle = bestVideo.snippet.title; // Store video title
                currentVideoDescription = bestVideo.snippet.description; // Store video description
                chapterDisplay.textContent = currentVideoTitle; // Update chapter display with video title
                // Proceed to fetch/generate checkpoints for the selected video.
                await getCheckpoints(bestVideo.id, currentVideoTitle, currentVideoDescription);
            } else {
                // If no suitable video was found after all attempts.
                showMessageBox(`Could not find a suitable video for "${CHAPTER_NAME}" after all attempts. Please try a different chapter name or check your API key.`);
                loadingSpinner.style.display = 'none'; // Hide loading spinner
            }
        }

        /**
         * Parses a YouTube ISO 8601 duration string (e.g., "PT1H2M3S") into total seconds.
         * @param {string} isoDuration The ISO 8601 duration string provided by YouTube API.
         * @returns {number} The total duration converted into seconds.
         */
        function parseYouTubeDuration(isoDuration) {
            // Regex to extract days, hours, minutes, and seconds from ISO 8601 duration.
            const regex = /P(?:(\d+)D)?T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/;
            const matches = isoDuration.match(regex);
            if (!matches) return 0; // Return 0 if no match found

            // Parse extracted values, defaulting to 0 if not present.
            const days = parseInt(matches[1] || 0);
            const hours = parseInt(matches[2] || 0);
            const minutes = parseInt(matches[3] || 0);
            const seconds = parseInt(matches[4] || 0);

            // Calculate total seconds.
            return (days * 24 * 3600) + (hours * 3600) + (minutes * 60) + seconds;
        }

        /**
         * Formats a given number of seconds into a human-readable "MM:SS" time string.
         * @param {number} seconds The time duration in seconds.
         * @returns {string} The formatted time string (e.g., "05:30", "60:00").
         */
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            // Pad with leading zero if single digit for consistent formatting.
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }

        /**
         * Uses the Gemini API to analyze the video's metadata (title, description, duration)
         * and generate a set of spaced checkpoints, each with multiple-choice questions.
         * It iterates through the available API keys until a successful response is received.
         * @param {string} videoId The YouTube video ID.
         * @param {string} videoTitle The title of the video.
         * @param {string} videoDescription The description of the video.
         */
        async function getCheckpoints(videoId, videoTitle, videoDescription) {
            showMessageBox('Analyzing video content and generating questions...');
            loadingSpinner.style.display = 'block';

            // Construct a detailed prompt for the Gemini LLM.
            // It requests specific formatting (JSON array of checkpoints with questions).
            const prompt = `
            The following is a YouTube video about "${CHAPTER_NAME}".
            Video Title: "${videoTitle}"
            Video Description: "${videoDescription.slice(0, 1000)}..." (trimmed description for brevity)
            Video Duration: ${currentVideoDuration} seconds (${formatTime(currentVideoDuration)})

            Your task is to:
            1. Identify 3-4 significant topic transitions or 'checkpoints' within the video content based on the title and description. For each checkpoint, provide a timestamp in seconds. These timestamps should be reasonably spaced throughout the video duration.
            2. For each identified checkpoint, generate:
                a. An array of 10-12 multiple-choice questions (MCQs) that cover the content discussed *before* that checkpoint. Each question should have 4 options (A, B, C, D) and clearly indicate the correct answer.

            Provide the output as a JSON array of objects. Each object represents a checkpoint and contains:
            - "timestamp": The checkpoint time in seconds (integer).
            - "topic": A brief description of the topic covered up to this point.
            - "text_questions": [ // Array of question objects
                {
                    "question_text": "Question 1 text?",
                    "options": ["A. Option A", "B. Option B", "C. Option C", "D. Option D"],
                    "correct_answer": "A"
                }
                // ... more questions
            ],
            `;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json", // Instruct Gemini to return JSON
                    responseSchema: { // Define the expected JSON structure for validation
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "timestamp": { "type": "NUMBER" },
                                "topic": { "type": "STRING" },
                                "text_questions": {
                                    type: "ARRAY",
                                    items: {
                                        type: "OBJECT",
                                        properties: {
                                            "question_text": { "type": "STRING" },
                                            "options": { "type": "ARRAY", "items": { "type": "STRING" } },
                                            "correct_answer": { "type": "STRING" }
                                        },
                                        "required": ["question_text", "options", "correct_answer"]
                                    }
                                }
                            },
                            "required": ["timestamp", "topic", "text_questions"]
                        }
                    }
                }
            };
            
            let attempts = 0;
            while (attempts < GEMINI_API_KEYS.length) {
                const apiKey = GEMINI_API_KEYS[currentGeminiApiKeyIndex % GEMINI_API_KEYS.length]; // Cycle through keys
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log('Gemini API Raw Response for Checkpoints:', result);

                        if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                            const jsonString = result.candidates[0].content.parts[0].text;
                            const parsedCheckpoints = JSON.parse(jsonString);

                            checkpoints = parsedCheckpoints.filter(cp => 
                                cp.timestamp > 0 && cp.timestamp < currentVideoDuration * 0.95 
                            ).sort((a, b) => a.timestamp - b.timestamp);

                            if (checkpoints.length === 0) {
                                console.warn('AI could not identify suitable checkpoints or generate valid questions with this key.');
                            } else {
                                console.log('Generated and Filtered Checkpoints with Questions:', checkpoints);
                                hideMessageBox();
                                currentGeminiApiKeyIndex = 0; // Reset index on success
                                return; // Exit function on success
                            }
                        } else {
                            console.warn('Invalid response structure from Gemini API when generating questions with this key.');
                        }
                    } else if (response.status === 403 || response.status === 400) {
                        console.warn(`Gemini API key (index ${currentGeminiApiKeyIndex % GEMINI_API_KEYS.length}) failed with status ${response.status} for checkpoint generation. Trying next key...`);
                    } else if (response.status === 503) {
                         // Specific handling for 503 Service Unavailable
                        console.error(`Gemini API Service Unavailable (Status 503) for checkpoint generation with key (index ${currentGeminiApiKeyIndex % GEMINI_API_KEYS.length}). Trying next key...`);
                        showMessageBox("Gemini API is temporarily unavailable. Please try again in a few moments.");
                    } else {
                        console.error(`Error fetching checkpoints with Gemini key (index ${currentGeminiApiKeyIndex % GEMINI_API_KEYS.length}): Status ${response.status} - ${response.statusText}`);
                    }
                } catch (error) {
                    console.error(`Network error fetching checkpoints with Gemini key (index ${currentGeminiApiKeyIndex % GEMINI_API_KEYS.length}):`, error);
                }
                currentGeminiApiKeyIndex++; // Move to the next key
                attempts++;
            }
            console.error("All Gemini API keys failed to generate checkpoints.");
            showMessageBox(`Failed to generate questions after multiple attempts. The Gemini API might be experiencing issues. Please try again later.`);
            checkpoints = []; // Reset checkpoints on total failure
            loadingSpinner.style.display = 'none'; // Always hide spinner
        }

        /**
         * Dynamically displays the text questions for the current checkpoint.
         * Clears previous questions and renders new ones, including hint buttons and visual aid buttons.
         * @param {Array<Object>} textQuestionsData An array of question objects.
         */
        function displayTextQuestions(textQuestionsData) {
            questionsSection.classList.remove('hidden'); // Show the questions section
            questionsSection.classList.add('is-active'); // Add active class for styling/logic
            externalGameContainer.classList.add('hidden'); // Ensure external game is hidden
            youtubePlayerDiv.classList.add('hidden'); // Hide YouTube player when questions are active
            videoInfo.classList.add('hidden'); // Hide video info when questions are active

            textQuestionsArea.innerHTML = ''; // Clear any previously displayed questions

            // Iterate through each question and create its DOM elements.
            textQuestionsData.forEach((q, qIndex) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'text-question-item'; 
                questionDiv.innerHTML = `<p>${qIndex + 1}. ${q.question_text}</p><div class="text-question-options"></div>`;
                const optionsContainer = questionDiv.querySelector('.text-question-options');

                // Add radio button options for each question.
                q.options.forEach((option, oIndex) => {
                    const optionId = `q${qIndex}-option-${oIndex}`;
                    const label = document.createElement('label');
                    // Removed the redundant String.fromCharCode(65 + oIndex) as the `option` text already contains the letter.
                    label.innerHTML = `<input type="radio" name="question-${qIndex}" value="${String.fromCharCode(65 + oIndex)}" id="${optionId}"> ${option}`;
                    optionsContainer.appendChild(label);
                });

                // Add a "Get Hint" button for each question.
                const hintButton = document.createElement('button');
                hintButton.className = 'hint-button';
                hintButton.textContent = 'Get Hint ✨';
                hintButton.dataset.questionIndex = qIndex; // Store question index for event delegation

                // Add a div where the hint will be displayed.
                const hintDisplay = document.createElement('div');
                hintDisplay.className = 'hint-display';

                questionDiv.appendChild(hintButton);
                questionDiv.appendChild(hintDisplay); // This places it right after the button.
                
                textQuestionsArea.appendChild(questionDiv); // Add the full question div to the area
            });

            submitChallengeBtn.disabled = false; // Enable the submit button once questions are loaded
        }

        /**
         * Retrieves a subtle hint for a given multiple-choice question from the Gemini API.
         * The hint is designed to guide the user without revealing the direct answer.
         * It iterates through the available API keys until a successful response is received.
         * @param {string} questionText The full text of the question.
         * @param {Array<string>} options The options for the question.
         * @returns {Promise<string>} A promise resolving to the hint text.
         */
        async function getHint(questionText, options) {
            showMessageBox('Generating hint...');
            loadingSpinner.style.display = 'block';

            const prompt = `
            The user is learning about "${CHAPTER_NAME}" through a video.
            Here is a multiple-choice question they are currently trying to answer:

            Question: "${questionText}"
            Options: ${options.map((opt, i) => `${String.fromCharCode(65 + i)}. ${opt}`).join('\n')}

            Please provide a subtle hint for this question. Do NOT reveal the direct answer.
            The hint should guide the user towards the concept or area they should focus on in the video to find the answer.
            Keep the hint concise, ideally one or two sentences.
            `;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "text/plain" // Expect plain text response for hint
                }
            };
            
            let attempts = 0;
            while (attempts < GEMINI_API_KEYS.length) {
                const apiKey = GEMINI_API_KEYS[currentGeminiApiKeyIndex % GEMINI_API_KEYS.length]; // Cycle through keys
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log('Gemini API Raw Response for Hint:', result);

                        if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                            const hintText = result.candidates[0].content.parts[0].text;
                            console.log('Generated hint:', hintText);
                            hideMessageBox();
                            currentGeminiApiKeyIndex = 0; // Reset index on success
                            return hintText; // Exit function on success
                        } else {
                            console.warn('Invalid response structure from Gemini API when generating hint with this key.');
                        }
                    } else if (response.status === 403 || response.status === 400) {
                        console.warn(`Gemini API key (index ${currentGeminiApiKeyIndex % GEMINI_API_KEYS.length}) failed with status ${response.status} for hint generation. Trying next key...`);
                    } else if (response.status === 503) {
                         // Specific handling for 503 Service Unavailable
                        console.error(`Gemini API Service Unavailable (Status 503) for hint generation with key (index ${currentGeminiApiKeyIndex % GEMINI_API_KEYS.length}). Trying next key...`);
                        showMessageBox("Gemini API is temporarily unavailable for hints. Please try again in a few moments.");
                    } else {
                        console.error(`Error fetching hint with Gemini key (index ${currentGeminiApiKeyIndex % GEMINI_API_KEYS.length}): Status ${response.status} - ${response.statusText}`);
                    }
                } catch (error) {
                    console.error(`Network error fetching hint with Gemini key (index ${currentGeminiApiKeyIndex % GEMINI_API_KEYS.length}):`, error);
                }
                currentGeminiApiKeyIndex++; // Move to the next key
                attempts++;
            }
            console.error("All Gemini API keys failed to generate hint.");
            showMessageBox(`Could not generate a hint after trying all API keys. The Gemini API might be experiencing issues. Please try again later.`);
            loadingSpinner.style.display = 'none';
            return 'Sorry, I cannot provide a hint right now.'; // Fallback if all keys fail
        }


        /**
         * Checks the user's answers for all text questions at the current checkpoint.
         * Provides visual feedback (green/red background) and updates score.
         * Decides next steps: resume video, regenerate questions, or proceed to final game.
         */
        function checkCheckpointAnswers() {
            const currentCheckpoint = checkpoints[currentCheckpointIndex];
            if (!currentCheckpoint || !currentCheckpoint.text_questions) {
                showMessageBox('No checkpoint questions to check.');
                return;
            }

            let allTextQuestionsCorrectForThisCheckpoint = true;
            let questionsAttemptedInThisCheckpoint = 0;
            let questionsCorrectInThisCheckpoint = 0;

            currentCheckpoint.text_questions.forEach((q, qIndex) => {
                const selectedOption = document.querySelector(`input[name="question-${qIndex}"]:checked`);
                const questionDiv = document.querySelector(`.text-question-item:nth-child(${qIndex + 1})`); 
                
                questionsAttemptedInThisCheckpoint++; // Increment for each question processed

                if (!selectedOption || selectedOption.value !== q.correct_answer) {
                    allTextQuestionsCorrectForThisCheckpoint = false;
                    if (questionDiv) {
                        questionDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.3)'; // Red for incorrect
                    }
                } else {
                    questionsCorrectInThisCheckpoint++; // Increment for each correct question
                    if (questionDiv) {
                        questionDiv.style.backgroundColor = 'rgba(0, 255, 0, 0.3)'; // Green for correct
                    }
                    updateScore(1, 'question'); // Award 1 point for each individually correct question
                }
            });

            // Calculate score for this specific checkpoint
            const checkpointScorePercentage = (questionsCorrectInThisCheckpoint / questionsAttemptedInThisCheckpoint) * 100;

            // Update global chapter question counts
            window.correctQuestionsInCurrentChapter += questionsCorrectInThisCheckpoint;
            window.totalQuestionsAttemptedInCurrentChapter += questionsAttemptedInThisCheckpoint;
            saveGameData(); // Persist the updated counts

            // const chapterOverallPercentage = getChapterCompletionPercentage(); // Not directly used here, but good for context

            if (checkpointScorePercentage >= CHECKPOINT_PASS_SCORE_PERCENTAGE) {
                // User passed the current checkpoint
                updateScore(10, 'checkpoint_bonus'); // Award bonus points for clearing the entire checkpoint
                showVictoryAnimation(`Great! You passed this checkpoint (${checkpointScorePercentage.toFixed(0)}%)!`);
                
                // Hide questions, show video and info
                questionsSection.classList.add('hidden');
                questionsSection.classList.remove('is-active'); // Deactivate state
                youtubePlayerDiv.classList.remove('hidden'); // Show YouTube player again
                videoInfo.classList.remove('hidden'); // Show video info again
                youtubePlayerOverlay.classList.remove('active-overlay'); // Enable player controls
                
                // Video resumes from the current checkpoint's timestamp (where questions were asked) + 1 second
                // The next questions will appear at the *next* checkpoint naturally.
                if (player) {
                    player.setVolume(100); 
                    player.seekTo(currentCheckpoint.timestamp + 1, true); // <--- CHANGE HERE
                    player.playVideo(); 
                }
                window.needsQuestionRegeneration = false; // Reset regeneration flag as checkpoint was passed

                // Advance checkpoint index after seeking. This is important so monitorVideoTime
                // knows to look for the *next* checkpoint.
                currentCheckpointIndex++; 
                saveGameData(); // Save updated checkpoint index after advancing
            } else { // Checkpoint failed
                // Set flag for regeneration on next re-trigger of this checkpoint
                window.needsQuestionRegeneration = true; 

                showGameOverAnimation(`Checkpoint failed (${checkpointScorePercentage.toFixed(0)}%). Review & try again!`, () => {
                    youtubePlayerDiv.classList.remove('hidden'); 
                    videoInfo.classList.remove('hidden');
                    questionsSection.classList.add('hidden'); 
                    questionsSection.classList.remove('is-active');
                    youtubePlayerOverlay.classList.remove('active-overlay'); // Enable player controls

                    let seekToTimeForReview;
                    if (currentCheckpointIndex === 0) {
                        // If the first checkpoint failed, restart video from 0:00
                        seekToTimeForReview = 0; 
                    } else {
                        // For subsequent checkpoints, go back to the start of the PREVIOUS checkpoint's segment
                        // The previous checkpoint's timestamp marks the beginning of the current segment
                        seekToTimeForReview = checkpoints[currentCheckpointIndex - 1].timestamp;
                    }
                    
                    if (player) {
                        player.setVolume(100); 
                        player.seekTo(seekToTimeForReview, true);
                        player.playVideo(); 
                    }
                    // currentCheckpointIndex is NOT changed here. It remains pointing to the failed checkpoint.
                    // This is correct, as the video will rewind and then monitorVideoTime will re-trigger
                    // the *same* checkpoint when it reaches `checkpoints[currentCheckpointIndex].timestamp` again,
                    // and `window.needsQuestionRegeneration` will ensure new questions are loaded.
                });
            }
        }

        /**
         * Regenerates a new set of text questions for the current checkpoint if the user failed.
         * This ensures a fresh challenge is provided upon reattempt, using the Gemini API.
         */
        async function regenerateCheckpointQuestions() {
            const currentCheckpoint = checkpoints[currentCheckpointIndex];
            if (!currentCheckpoint) return; // Exit if no valid checkpoint is active

            // This message is now handled by monitorVideoTime before calling this function
            // showMessageBox('Generating a new set of questions for this checkpoint...');
            loadingSpinner.style.display = 'block'; // Show spinner while regenerating

            // Prompt Gemini for new questions, emphasizing they should be "new and different".
            const prompt = `
            The user failed the previous challenge for the video content around ${formatTime(currentCheckpoint.timestamp)} (topic: "${currentCheckpoint.topic}").
            Generate a *new and different* array of 10-12 multiple-choice questions (MCQs) that cover the content discussed *before* this timestamp. Each question should have 4 options (A, B, C, D) and clearly indicate the correct answer.
            `;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json", // Expect JSON response
                    responseSchema: { // Define expected JSON schema
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "question_text": { "type": "STRING" },
                                "options": { "type": "ARRAY", "items": { "type": "STRING" } },
                                "correct_answer": { "type": "STRING" }
                            },
                            "required": ["question_text", "options", "correct_answer"]
                        }
                    }
                }
            };
            
            let attempts = 0;
            while (attempts < GEMINI_API_KEYS.length) {
                const apiKey = GEMINI_API_KEYS[currentGeminiApiKeyIndex % GEMINI_API_KEYS.length]; // Cycle through keys
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        const newQuestionsData = JSON.parse(result.candidates[0].content.parts[0].text);

                        if (newQuestionsData && Array.isArray(newQuestionsData) && newQuestionsData.length > 0) {
                            currentCheckpoint.text_questions = newQuestionsData; 
                            // displayTextQuestions(newQuestionsData); // This is called after the promise resolves in monitorVideoTime
                            loadingSpinner.style.display = 'none'; // Hide spinner on success
                            currentGeminiApiKeyIndex = 0; // Reset index on success
                            return; // Exit function on success
                        } else {
                            console.warn('AI could not generate new question data for the checkpoint with this key.');
                        }
                    } else if (response.status === 403 || response.status === 400) {
                        console.warn(`Gemini API key (index ${currentGeminiApiKeyIndex % GEMINI_API_KEYS.length}) failed with status ${response.status} for question regeneration. Trying next key...`);
                    } else if (response.status === 503) {
                         // Specific handling for 503 Service Unavailable
                        console.error(`Gemini API Service Unavailable (Status 503) for question regeneration with key (index ${currentGeminiApiKeyIndex % GEMINI_API_KEYS.length}). Trying next key...`);
                        showMessageBox("Gemini API is temporarily unavailable for question regeneration. Please try again in a few moments.");
                    } else {
                        console.error(`Error regenerating challenge questions with Gemini key (index ${currentGeminiApiKeyIndex % GEMINI_API_KEYS.length}): Status ${response.status} - ${response.statusText}`);
                    }
                } catch (error) {
                    console.error(`Network error regenerating challenge questions with Gemini key (index ${currentGeminiApiKeyIndex % GEMINI_API_KEYS.length}):`, error);
                }
                currentGeminiApiKeyIndex++; // Move to the next key
                attempts++;
            }
            console.error("All Gemini API keys failed to regenerate questions.");
            showMessageBox(`Could not generate new questions after trying all API keys. The Gemini API might be experiencing issues. Please try again later.`);
            loadingSpinner.style.display = 'none'; 
            questionsSection.classList.remove('hidden'); 
            questionsSection.classList.add('is-active');
            throw new Error("Failed to regenerate questions after all API key attempts."); // Propagate error
        }

        /**
         * Displays the final external game challenge by making its container visible
         * and setting the iframe source to the game URL.
         * This function will only be called if the chapter is NOT completed by score (i.e., less than 80%).
         */
        function displayFinalGameChallenge() {
            questionsSection.classList.add('hidden'); // Hide the questions section
            youtubePlayerDiv.classList.add('hidden'); // Hide YouTube player when game is active
            videoInfo.classList.add('hidden'); // Hide video info when game is active
            youtubePlayerOverlay.classList.add('active-overlay'); // Disable player controls during game
            externalGameContainer.classList.remove('hidden'); // Show the external game container

            externalGameIframe.src = EXTERNAL_GAME_URL; // Set the source of the iframe to the game URL
            markGameCompleteBtn.disabled = false; // Enable the "Mark Game as Complete" button
        }

        /**
         * Handles the completion of the final external game challenge.
         * Awards points, updates level, marks the chapter as complete, and redirects.
         */
        function markExternalGameAsComplete() {
            // Check if the chapter was *already* completed by score, if so, don't re-award points or level.
            const isChapterCompleted = localStorage.getItem(`chapterCompleted_${CHAPTER_NAME}_${currentUserId}`);
            if (isChapterCompleted === 'true') {
                showMessageBox(`Chapter "${CHAPTER_NAME}" was already completed by score. Redirecting to the next chapter...`);
                const currentPath = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                setTimeout(() => {
                    window.location.href = currentPath + NEXT_CHAPTER_URL;
                }, 2000); 
                return;
            }

            // If not already completed, proceed with game completion logic
            updateScore(20, 'game'); // Award 20 points for game completion
            updateLevel(1); // Increment user level

            localStorage.setItem(`chapterCompleted_${CHAPTER_NAME}_${currentUserId}`, 'true');

            showVictoryAnimation(`Great job! You completed the Final Game Challenge and the chapter!`, () => {
                // Redirect to the next chapter after a short delay to allow message display.
                const currentPath = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
                window.location.href = currentPath + NEXT_CHAPTER_URL;
            });
            
            externalGameContainer.classList.add('hidden'); // Hide the game container
            youtubePlayerOverlay.classList.remove('active-overlay'); // Enable player controls after game
        }


        // --- Event Listeners ---
        // Attaching event listeners for user interactions.

        // Theme toggle switch: changes 'light-mode' class on the body and updates Local Storage.
        themeToggle.addEventListener('change', function() {
            if (this.checked) {
                body.classList.add('light-mode');
                localStorage.setItem('theme', 'light');
            } else {
                body.classList.remove('light-mode');
                localStorage.setItem('theme', 'dark');
            }
        });

        // Event listener for the "OK" button in the custom message box.
        messageOkBtn.addEventListener('click', hideMessageBox);

        // Event listener for the "Submit Challenge" button to check checkpoint answers.
        submitChallengeBtn.addEventListener('click', checkCheckpointAnswers);

        // Event listener for the "Mark Game as Complete" button.
        markGameCompleteBtn.addEventListener('click', markExternalGameAsComplete);

        // Event delegation for "Get Hint" button clicks.
        questionsSection.addEventListener('click', async (event) => {
            if (event.target.classList.contains('hint-button') && event.target.textContent.includes('Hint')) {
                const button = event.target;
                const qIndex = parseInt(button.dataset.questionIndex); 
                const currentCheckpoint = checkpoints[currentCheckpointIndex];
                if (!currentCheckpoint || !currentCheckpoint.text_questions[qIndex]) {
                    showMessageBox('Could not find question data for hint.');
                    return;
                }
                const questionData = currentCheckpoint.text_questions[qIndex];
                
                // Find the hint display element by checking its proximity (next sibling after button)
                let hintDisplayElement = button.nextElementSibling;
                // Ensure it's the actual hint display div, not another button or container
                while(hintDisplayElement && !hintDisplayElement.classList.contains('hint-display')) {
                    hintDisplayElement = hintDisplayElement.nextElementSibling;
                }

                // Check if hint is already displayed to prevent redundant generation
                if (hintDisplayElement && hintDisplayElement.textContent.trim() !== '' && hintDisplayElement.style.display !== 'none') {
                    showMessageBox('Hint already displayed for this question.');
                    return;
                }

                const hint = await getHint(questionData.question_text, questionData.options);
                if (hintDisplayElement) {
                    hintDisplayElement.textContent = hint;
                    hintDisplayElement.style.display = 'block'; // Make hint visible
                }
            } 
        });


        // --- Initialization on Page Load ---
        // This function runs when the entire page content has been loaded.
        window.onload = async function() {
            // Apply the saved theme preference (light or dark) from Local Storage.
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                body.classList.add('light-mode');
                themeToggle.checked = true;
            }

            // Load saved game data and check if the current chapter is already completed.
            loadGameData();
            
            // If the chapter is already completed, loadGameData will handle redirection.
            if (localStorage.getItem(`chapterCompleted_${CHAPTER_NAME}_${currentUserId}`) === 'true') {
                return; // Exit if chapter is already complete, as loadGameData has initiated redirect.
            }

            // Load the YouTube Iframe API script asynchronously.
            // This is crucial to ensure `YT.Player` is defined when `createYoutubePlayer` is called.
            loadYoutubeIframeAPI(); 
            
            // Wait for the YouTube Iframe API to be ready before proceeding with video loading.
            await youtubeApiReadyPromise;

            // Determine the user's language based on default coordinates (as IP fetching can be unreliable).
            const userLocation = DEFAULT_COORDS; 
            const userLanguage = getLanguageFromCountry(userLocation.countryCode);
            
            // --- Primary Video Loading Logic ---
            let videoToLoad = null;
            if (USER_PROVIDED_VIDEO_LINK) {
                showMessageBox('Attempting to load user-provided video link...');
                loadingSpinner.style.display = 'block';
                const userVideoId = getYouTubeVideoId(USER_PROVIDED_VIDEO_LINK);
                if (userVideoId) {
                    const videoDetails = await fetchVideoDetailsById(userVideoId);
                    if (videoDetails) {
                        videoToLoad = videoDetails;
                        console.log("Successfully loaded user-provided video:", videoToLoad);
                    } else {
                        // This else block handles cases where the user-provided video link
                        // was valid, but YouTube API could not fetch its details (e.g., restricted video).
                        showMessageBox('User-provided video not found or could not be loaded. Falling back to search.');
                        console.warn("User-provided video failed to load, falling back to search.");
                    }
                } else {
                    // This else block handles cases where the user-provided string was not a valid YouTube URL.
                    showMessageBox('Invalid user-provided YouTube URL. Falling back to search.');
                    console.warn("Invalid user-provided YouTube URL, falling back to search.");
                }
            }

            if (videoToLoad) {
                // If a valid video was identified from the user-provided link (or its details fetched successfully).
                createYoutubePlayer(videoToLoad.id);
                currentVideoDuration = videoToLoad.durationSeconds;
                currentVideoTitle = videoToLoad.snippet.title;
                currentVideoDescription = videoToLoad.snippet.description;
                chapterDisplay.textContent = currentVideoTitle;
                await getCheckpoints(videoToLoad.id, currentVideoTitle, videoToLoad.snippet.description); // Pass full description
            } else {
                // If no user-provided video, or it failed to load/validate, proceed with dynamic search.
                searchYouTubeVideo(CHAPTER_NAME, userLanguage); 
            }
        };
    </script>
</body>
</html>
